-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Main where

import DA.Next.Set as S
import DA.Assert

template IssuanceRequest
  with
    owner : Party
    validators : Set Party
    validatorOverlapThreshold : Decimal
    balance : Decimal
    signed : Set Party
  where
    signatory owner, signed
    observer owner, validators

    choice Sign : ContractId IssuanceRequest
      with signee : Party
      controller signee
      do
        assert $ S.member signee validators
        create this with signed = S.insert signee signed

    choice Issue : ContractId Wallet
      with issuer : Party
      controller issuer
      do
        validators === signed
        assert $ S.member issuer signed
        create Wallet with ..

template Wallet
  with
    owner : Party
    validators : Set Party
    validatorOverlapThreshold : Decimal
    balance : Decimal
  where
    ensure balance >= 0.0
    signatory owner, validators
    controller owner can
      Split : (ContractId Wallet, ContractId Wallet)
        with
          validatorSubset : Set Party
          amount : Decimal
        do
          assert $ amount <= balance
          assert $ S.intersection validatorSubset validators == validatorSubset
          newWallet <- create this with validators = validatorSubset; balance = amount
          oldWallet <- create this with balance = balance - amount
          pure (oldWallet, newWallet)

      RequestTransfer : (ContractId Wallet, ContractId TransferRequest)
        with
          newOwner : Party
          transferValidators : Set Party
          amount : Decimal
        do
          let overlap = S.intersection transferValidators validators
          let overlapPerc = (intToDecimal $ S.size overlap) / (intToDecimal $ S.size validators)
          assert $ overlapPerc >= validatorOverlapThreshold
          wallet <- create this with balance = balance - amount
          request <- create TransferRequest with
            sender = owner
            receiver = newOwner
            validators = transferValidators
            amount
          pure (wallet, request)

      CancelTransfer : ContractId Wallet
        with
          transferRequestCid : ContractId TransferRequest
        do
          transferRequest <- fetch transferRequestCid
          transferRequest.sender === owner
          archive transferRequestCid
          create this with balance = balance + transferRequest.amount

      AcceptTransfer : ContractId Wallet
        with
          transferRequestCid : ContractId TransferRequest
        do
          transferRequest <- fetch transferRequestCid
          transferRequest.receiver === owner
          let overlap = S.intersection transferRequest.validators validators
          let overlapPerc = (intToDecimal $ S.size overlap) / (intToDecimal $ S.size validators)
          assert $ overlapPerc >= validatorOverlapThreshold
          exercise transferRequestCid Delete
          create this with balance = balance + transferRequest.amount

template TransferRequest
  with
    sender : Party
    receiver : Party
    validators : Set Party
    amount : Decimal
  where
    ensure amount > 0.0
    signatory sender, validators
    observer receiver

    controller receiver, validators can
      Delete : ()
        do pure ()

data Fixture = Fixture with
  alice : Party
  bob : Party
  charlie : Party
  a : Party
  b : Party
  c : Party
  d : Party
  e : Party
  walletAliceCid : ContractId Wallet
  walletBobCid : ContractId Wallet
  walletCharlieCid : ContractId Wallet

fixture = scenario do
  alice <- getParty "Alice"
  bob <- getParty "Bob"
  charlie <- getParty "Charlie"
  a <- getParty "Val_A"
  b <- getParty "Val_B"
  c <- getParty "Val_C"
  d <- getParty "Val_D"
  e <- getParty "Val_E"

  -- Issue a wallet to Alice
  irA <- submit alice do
    create IssuanceRequest with
      owner = alice
      validators = S.fromList [ a, b, c ]
      validatorOverlapThreshold = 0.5
      balance = 1000.0
      signed = S.empty
  irA <- submit a do exercise irA Sign with signee = a
  irA <- submit b do exercise irA Sign with signee = b
  irA <- submit c do exercise irA Sign with signee = c
  walletAliceCid <- submit a do exercise irA Issue with issuer = a

  -- Issue a wallet to Bob
  irB <- submit bob do
    create IssuanceRequest with
      owner = bob
      validators = S.fromList [ b, c, d ]
      validatorOverlapThreshold = 0.5
      balance = 1000.0
      signed = S.empty
  irB <- submit b do exercise irB Sign with signee = b
  irB <- submit c do exercise irB Sign with signee = c
  irB <- submit d do exercise irB Sign with signee = d
  walletBobCid <- submit b do exercise irB Issue with issuer = b

  -- Issue a wallet to Bob
  irC <- submit charlie do
    create IssuanceRequest with
      owner = charlie
      validators = S.fromList [ c, d, e ]
      validatorOverlapThreshold = 0.5
      balance = 1000.0
      signed = S.empty
  irC <- submit c do exercise irC Sign with signee = c
  irC <- submit d do exercise irC Sign with signee = d
  irC <- submit e do exercise irC Sign with signee = e
  walletCharlieCid <- submit c do exercise irC Issue with issuer = c

  pure Fixture with ..

-- Counterparty and 3rd party validators don't see one's wallet
test1 = scenario do
  Fixture{..} <- fixture

  -- Alice requests a transfer to Bob
  (walletAliceCid, tr) <- submit alice do
    exercise walletAliceCid RequestTransfer with
      newOwner = bob
      transferValidators = S.fromList [ b, c ]
      amount = 200.0

  -- Verify the transfer is only disclosed to Alice's chosen validators
  -- Note: Alice's other validators will be devulged the transfer, but they cannot fetch it
  submitMustFail a do fetch tr
  submit b do fetch tr
  submit c do fetch tr
  submitMustFail d do fetch tr

  -- Bob accepts the transfer
  walletBobCid <- submit bob do
    exercise walletBobCid AcceptTransfer with
      transferRequestCid = tr

  -- Verify transfer happened
  walletAlice <- submit alice do fetch walletAliceCid
  walletBob <- submit bob do fetch walletBobCid
  walletAlice.balance === 800.0
  walletBob.balance === 1200.0

  -- Verify validator visibility
  submitMustFail d do fetch walletAliceCid
  submitMustFail a do fetch walletBobCid
  submitMustFail bob do fetch walletAliceCid
  submitMustFail alice do fetch walletBobCid

  -- Bob requests a transfer to Charlie
  (walletBobCid, tr) <- submit bob do
    exercise walletBobCid RequestTransfer with
      newOwner = charlie
      transferValidators = S.fromList [ c, d ]
      amount = 200.0

  -- Verify the transfer is only disclosed to Bob's chosen validators
  -- Note: Bob's other validators will be devulged the transfer, but they cannot fetch it
  submitMustFail a do fetch tr
  submitMustFail b do fetch tr
  submit c do fetch tr
  submit d do fetch tr
  submitMustFail e do fetch tr

  -- Charlie's accepts the transfer
  walletCharlieCid <- submit charlie do
    exercise walletCharlieCid AcceptTransfer with
      transferRequestCid = tr

  -- Verify transfer happened
  walletBob <- submit bob do fetch walletBobCid
  walletCharlie <- submit charlie do fetch walletCharlieCid
  walletBob.balance === 1000.0
  walletCharlie.balance === 1200.0

  -- Verify validator visibility
  submitMustFail e do fetch walletBobCid
  submitMustFail b do fetch walletCharlieCid
  submitMustFail charlie do fetch walletBobCid
  submitMustFail bob do fetch walletCharlieCid

-- Unsuccessful transfer due to insufficient validator overlap
test2 = scenario do
  Fixture{..} <- fixture
  -- Alice requests another transfer to Bob
  (walletAlice, tr) <- submit alice do
    exercise walletAliceCid RequestTransfer with
      newOwner = bob
      transferValidators = S.fromList [ a, b ]
      amount = 200.0
  
  -- Bob can't accept the transfer (overlap too small)
  submitMustFail bob do
    exercise walletBobCid AcceptTransfer with
      transferRequestCid = tr

  -- Alice cancels the transfer
  submit alice do
    exercise walletAlice CancelTransfer with
      transferRequestCid = tr
