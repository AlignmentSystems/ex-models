-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Chess where

import DA.Assert

import Rules.Main
import Rules.Data
import Rules.Draw
import Types

-- As part of beginning operator flow
-- we'll refactor this later to create gameId's.

type GameContractIds = (ContractId ActiveSideOfGame, ContractId PassiveSideOfGame)

template GameProposal
  with
    gameId : GameId
    proposer : Party
  where
    let opponent = oppositeParty proposer gameId
        operator = gameId.operator
    signatory proposer
    controller opponent can
      InitGame : ContractId GameStart
        do
          create GameStart with ..

template GameStart
  with
    proposer : Party
    opponent : Party
    operator : Party
    gameId : GameId
  where
    signatory proposer, opponent
    controller operator can
      Start : GameContractIds
        do
          passiveId <- create PassiveSideOfGame with
                    player = opponent
                    operator
                    gameId
                    passive = Rules.Data.initSplitState Black
          activeId <- create ActiveSideOfGame with
                        player = proposer
                        operator
                        gameId
                        active = Rules.Data.initSplitState White
                        passiveId
          return (activeId, passiveId)

template GameResult
  with
    gameId : GameId
    game : Optional GameState
    winner : Optional Party
  where
    signatory gameId.operator

template PassiveSideOfGame
  with
    player : Party
    operator : Party
    gameId : GameId
    passive : SplitGameState
  where
    signatory player, operator
    controller operator can
      Activate : ContractId ActiveSideOfGame
        with
          active : SplitGameState
          passiveId : ContractId PassiveSideOfGame
        do
          create ActiveSideOfGame with ..
      End : ContractId GameResult
        with
          winner : Optional Party
          game : Optional GameState
        do
          create GameResult with ..

    controller player can
      Resign : ContractId GameResult
        do
          let opponent = oppositeParty player gameId
          create GameResult with winner = Some opponent, game = None, ..

template ActiveSideOfGame
  with
    player : Party
    operator : Party
    gameId : GameId
    active : SplitGameState
    passiveId : ContractId PassiveSideOfGame
  where
    signatory player, operator

    controller player can
      nonconsuming Move : ContractId ActiveMove
        with
          move : ChessMove
        do
          create ActiveMove with activeId = self, ..

    controller [operator, player] can
      MakePassive : ContractId PassiveSideOfGame
        with
          move : ChessMove
        do
          let passive = active with moves = move :: active.moves
          create PassiveSideOfGame with ..

template ActiveMove
  with
    player : Party
    operator : Party
    gameId : GameId
    active : SplitGameState
    move : ChessMove
    activeId : ContractId ActiveSideOfGame
    passiveId : ContractId PassiveSideOfGame  -- in lieu of a unique key setup.
  -- need a unique key to prevent double moves.
  where
    signatory operator, player
    controller operator can
      AdvancePlay : Either (ContractId GameResult) GameContractIds
        do
          passiveState <- fetch passiveId
          let joinedState = joinGameStates active.player active passiveState.passive
          case tryMove joinedState move of
            Winner player ->
              let winner =  if player == White then gameId.white else gameId.black in
              do
                win <- create GameResult with
                        winner = Some winner
                        game = Some joinedState
                        gameId
                return $ Left win
            Error e -> abort e
            NewState newJoinedState ->
              let whiteState = splitGameStateOfPlayer White newJoinedState
                  blackState = splitGameStateOfPlayer Black newJoinedState
                  active = if move.by == White then blackState else whiteState
              in
              do
                passiveId <- exercise activeId MakePassive with move
                activeId <- exercise passiveId Activate with passiveId, ..
                return $ Right (activeId, passiveId)