-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Chess where

import DA.Assert

import Rules.Main
import Rules.Data
import Rules.Draw
import Types

type GameId = Text
type GameContractIds = (ContractId ActiveSideOfGame, ContractId PassiveSideOfGame)

-- As part of beginning operator flow
-- we'll refactor this later to create gameId's.
template GameProposal
  with
    gameId : GameId
    proposer : Party
    desiredSide : Player
    opponent : Party
    operator : Party
  where
    signatory proposer
    controller opponent can
      InitGame : ContractId GameStart
        do
          create GameStart with ..

template GameStart
  with
    gameId : GameId
    proposer : Party
    desiredSide : Player
    opponent : Party
    operator : Party
  where
    signatory proposer, opponent
    -- signatory operator
    controller operator can
      Start : GameContractIds
        do
          let oppositePlayer p1 = if p1 == proposer then opponent else proposer
              (activePlayer, passivePlayer) =
                case desiredSide of
                  White -> (proposer, opponent)
                  Black -> (opponent, proposer)

          activeId <- create ActiveSideOfGame with
                          player = activePlayer
                          opponent = oppositePlayer activePlayer
                          active = Rules.Data.initSplitState White
                          side = White
                          ..
          passiveId <- create PassiveSideOfGame with
                          player = passivePlayer
                          opponent = oppositePlayer passivePlayer
                          passive = Rules.Data.initSplitState Black
                          side = Black
                          ..
          return (activeId, passiveId)

template GameResult
  with
    gameId : GameId
    operator : Party
    game : Optional GameState
    winner : Optional Party
  where
    signatory operator

type SideKey = (Party, GameId, Party)

template PassiveSideOfGame
  with
    player : Party
    side : Player
    operator : Party
    opponent : Party
    gameId : GameId
    passive : SplitGameState
  where
    signatory player, operator
    key (operator, gameId, player) : SideKey
    maintainer key._1

    controller operator can
      End : ContractId GameResult
        with
          winner : Optional Party
          game : Optional GameState
        do
          create GameResult with ..

    controller operator can

      Activate : ContractId ActiveSideOfGame
        with
          active : SplitGameState
        do
          create ActiveSideOfGame with ..

    controller player can
      Resign : ContractId GameResult
        do
          create GameResult with winner = Some opponent, game = None, ..

template ActiveSideOfGame
  with
    player : Party
    side : Player
    operator : Party
    opponent : Party
    gameId : GameId
    active : SplitGameState
  where
    signatory player, operator
    key (operator, gameId, player) : SideKey
    maintainer key._1

    controller player can
      nonconsuming Move : ContractId ActiveMove
        with
          move : ChessMove
        do
          create ActiveMove with ..

      Surrender : ContractId GameResult
        do
          create GameResult with winner = Some opponent, game = None, ..

    controller [operator, player] can
      -- operator can only take this action after receiving a unique Move,
      -- player is necessary to be signatory on Passive
      Inactivate : ContractId PassiveSideOfGame
        with
          passive : SplitGameState
        do
          create PassiveSideOfGame with ..
      EndActive : ()
        do return ()

template ActiveMove
  with
    player : Party
    operator : Party
    gameId : GameId
    opponent : Party
    move : ChessMove
    active : SplitGameState
  where
    signatory operator, player
    signatory operator--, player

    -- need a unique key to prevent double moves.
    key (operator, gameId, move) : (Party, GameId, ChessMove)
    maintainer key._1

    controller operator can
      AdvancePlay : Either (ContractId GameResult) GameContractIds
        do
          (activeId, activeState) <- fetchByKey @ActiveSideOfGame (operator, gameId, player)
          (passiveId, passiveState) <- fetchByKey @PassiveSideOfGame (operator, gameId, opponent)
          let currentState = joinGameStates active.player active passiveState.passive
              moveSide = activeState.side
          case tryMove currentState move of
            Winner player ->
              let winner = if player == moveSide then activeState.player else activeState.opponent in
              do
                let stateWithWinningMove = currentState with moves = (moveSide, move) :: currentState.moves
                win <- exercise passiveId End with
                            winner = Some winner
                            game = Some stateWithWinningMove
                exercise activeId EndActive
                return $ Left win
            Error e -> abort e
            NewState newJoinedState ->
              let whiteState = splitGameStateOfPlayer White newJoinedState
                  blackState = splitGameStateOfPlayer Black newJoinedState
                  (active, passive) =
                    case moveSide of
                      White -> (blackState, whiteState)
                      Black -> (whiteState, blackState)
              in
              do
                passiveId' <- exercise activeId Inactivate with passive
                activeId' <- exercise passiveId Activate with active
                return $ Right (activeId', passiveId')