-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Chess where

import DA.Assert

import Rules.Main
import Rules.Data
import Rules.Draw
import Types

-- As part of beginning operator flow
-- we'll refactor this later to create gameId's.

type GameContractIds = (ContractId ActiveSideOfGame, ContractId PassiveSideOfGame)

template GameProposal
  with
    gameId : GameId
    proposer : Party
  where
    let opponent = oppositePlayer proposer gameId
        operator = gameId.operator
    signatory proposer
    controller opponent can
      InitGame : ContractId StartGame
        do
          create StartGame with ..

template StartGame
  with
    proposer : Party
    opponent : Party
    operator : Party
    gameId : GameId
  where
    signatory proposer, opponent
    controller operator can
      DoIt : GameContractIds
        do
          passiveId <- create PassiveSideOfGame with
                    player = opponent
                    operator
                    gameId
                    passive = Rules.Data.initSplitState Black
          activeId <- create ActiveSideOfGame with
                        player = proposer
                        operator
                        gameId
                        active = Rules.Data.initSplitState White
                        passiveId
          return (activeId, passiveId)

template Result
  with
    game : GameState
    gameId : GameId
    winner : Optional Party
  where
    signatory gameId.operator

template PassiveSideOfGame
  with
    player : Party
    operator : Party
    gameId : GameId
    passive : SplitGameState
  where
    signatory player, operator
    controller operator can
      Activate : ContractId ActiveSideOfGame
        with
          active : SplitGameState
          passiveId : ContractId PassiveSideOfGame
        do
          create ActiveSideOfGame with ..
      End : ContractId Result
        with
          game : GameState
          winner : Optional Party
        do
          create Result with ..
    -- controller player can
      --Resign : ()

template ActiveSideOfGame
  with
    player : Party
    operator : Party
    gameId : GameId
    active : SplitGameState
    passiveId : ContractId PassiveSideOfGame
  where
    signatory player, operator

    controller player can
      nonconsuming Move : ContractId ActiveMove
        with
          move : ChessMove
        do
          create ActiveMove with activeId = self, ..

    controller [operator, player] can
      MakePassive : ContractId PassiveSideOfGame
        with
          move : ChessMove
        do
          let passive = active with moves = move :: active.moves
          create PassiveSideOfGame with ..


template ActiveMove
  with
    player : Party
    operator : Party
    gameId : GameId
    active : SplitGameState
    move : ChessMove
    activeId : ContractId ActiveSideOfGame
    passiveId : ContractId PassiveSideOfGame  -- in lieu of a unique key setup.
  -- need a unique key to prevent double moves.
  where
    signatory operator, player
    controller operator can
      AdvancePlay : Either (ContractId Result) GameContractIds
        do
          passiveState <- fetch passiveId
          let joinedState = joinGameStates active.player active passiveState.passive
          case tryMove joinedState move of
            Winner player ->
              let winner =  if player == White then gameId.white else gameId.black in
              do
                win <- create Result with winner = Some winner; game = joinedState, gameId
                return (Left win)
            Error e -> abort e
            NewState newJoinedState ->
              let whiteState = splitGameStateOfPlayer White newJoinedState
                  blackState = splitGameStateOfPlayer Black newJoinedState
                  active = if move.by == White then blackState else whiteState
              in
              do
                passiveId <- exercise activeId MakePassive with move
                activeId <- exercise passiveId Activate with passiveId, ..
                return (Right (activeId, passiveId))


