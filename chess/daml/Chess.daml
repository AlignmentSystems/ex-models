-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Chess where

import DA.Assert

import Rules.Main
import Rules.Data
import Rules.Draw
import Types

-- As part of beginning operator flow
-- we'll refactor this later to create gameId's.

type GameContractIds = (ContractId ActiveSideOfGame, ContractId PassiveSideOfGame)

template GameProposal
  with
    gameId : GameId
    proposer : Party
  where
    let receiver = oppositePlayer proposer gameId
        operator = gameId.operator
    signatory proposer

    controller operator can
      StartGame : GameContractIds
        do
          black <- create PassiveSideOfGame with
                    player = receiver
                    operator
                    gameId
                    passive = Rules.Data.initSplitState Black
          white <- create ActiveSideOfGame with
                    player = proposer
                    operator
                    gameId
                    active = Rules.Data.initSplitState White
                    passiveId = black
          return (white, black)

template Result
  with
    game : GameState
    gameId : GameId
    winner : Optional Party
  where
    signatory gameId.operator

template PassiveSideOfGame
  with
    player : Party
    operator : Party
    gameId : GameId
    passive : SplitGameState
  where
    signatory player, operator
    controller operator can
      Activate : ContractId ActiveSideOfGame
        with
          active : SplitGameState
          passiveId : ContractId PassiveSideOfGame
        do
          create ActiveSideOfGame with ..
      End : ContractId Result
        with
          game : GameState
          winner : Optional Party
        do
          create Result with ..

template ActiveMove
  with
    operator : Party
    gameId : GameId
    active : SplitGameState
    move : ChessMove
    activeId : ContractId ActiveSideOfGame
    passiveId : ContractId PassiveSideOfGame  -- in lieu of a unique key setup.
  where
    signatory operator
    controller operator can
      AdvancePlay : Either (ContractId Result) GameContractIds
        with
        do
          passiveState <- fetch passiveId
          let joinedState = joinGameStates active.player active passiveState.passive
          case tryMove joinedState move of
            Winner player ->
              let winner =  if player == White then gameId.white else gameId.black in
              do
                win <- create Result with winner = Some winner; game = joinedState, gameId
                return (Left win)
            Error e -> abort e
            NewState newJoinedState ->
              let whiteState = splitGameStateOfPlayer White newJoinedState
                  blackState = splitGameStateOfPlayer Black newJoinedState
                  active = if move.by == White then blackState else whiteState
              in
              do
                passiveId <- exercise activeId MakePassive with move
                activeId <- exercise passiveId Activate with passiveId, ..
                return (Right (activeId, passiveId))

template ActiveSideOfGame
  with
    player : Party
    operator : Party
    gameId : GameId
    active : SplitGameState
    passiveId : ContractId PassiveSideOfGame
  where
    signatory player, operator
    controller operator can
      MakePassive : ContractId PassiveSideOfGame
        with
          move : ChessMove
        do
          let passive = active with moves = move :: active.moves
          create PassiveSideOfGame with ..

    controller player can
      nonconsuming Move : ContractId ActiveMove
        with
          move : ChessMove
        do
          create ActiveMove with activeId = self, ..


