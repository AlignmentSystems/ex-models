-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Chess where


import Rules.Main
import Rules.Data
import Types

type GameId = Text
type GameContractIds = (ContractId ActiveSideOfGame, ContractId PassiveSideOfGame)

template GameProposal
  with
    gameId : GameId
    proposer : Party
    desiredSide : Side
    opponent : Party
    operator : Party
  where
    signatory proposer
    -- Only one game from proposer with the same id
    key (proposer, gameId) : (Party, GameId)
    maintainer key._1

    controller opponent can
      Accept : ContractId GameAccept
        do create GameAccept with ..

template GameAccept
  with
    gameId : GameId
    proposer : Party
    desiredSide : Side
    opponent : Party
    operator : Party
  where
    signatory proposer, opponent

    controller operator can
      Start : ContractId Game
        do create Game with ..

template Game
  with
    gameId : GameId
    proposer : Party
    desiredSide : Side
    opponent : Party
    operator : Party
  where
    signatory proposer, opponent, operator
    key (operator, gameId) : (Party, GameId)
    maintainer key._1
    controller operator can
      nonconsuming Begin : GameContractIds
        do
          let (activeSide, passiveSide) =
                case desiredSide of
                  White -> (proposer, opponent)
                  Black -> (opponent, proposer)

          activeId <- create ActiveSideOfGame with
                          player = activeSide
                          opponent = passiveSide
                          active = Rules.Data.initSplitState White
                          side = White
                          ..
          passiveId <- create PassiveSideOfGame with
                          player = passiveSide
                          opponent = activeSide
                          passive = Rules.Data.initSplitState Black
                          side = Black
                          ..
          return (activeId, passiveId)

      End : ContractId GameResult
        with
          game : Optional GameState
          drawOrWinner : Either DrawType Party
        do
          create GameResult with ..

template GameResult
  with
    opponent : Party
    proposer : Party
    gameId : GameId
    operator : Party
    game : Optional GameState
    drawOrWinner : Either DrawType Party
  where
    signatory proposer, opponent, operator

type SideKey = (Party, GameId, Party)

template PassiveSideOfGame
  with
    player : Party
    side : Side
    operator : Party
    opponent : Party
    gameId : GameId
    passive : GameState
  where
    signatory player, operator
    key (operator, gameId, player) : SideKey
    maintainer key._1

    controller operator can
      Activate : ContractId ActiveSideOfGame
        with
          active : GameState
        do create ActiveSideOfGame with ..
      DeclareWinnerPassive : ContractId GameResult --
        with
          result : ContractId GameResult
        do return result

    controller player can
      Resign : ContractId Surrender
        do create Surrender with ..
      AskForADraw : ContractId DrawRequest
        do create DrawRequest with ..

-- It is the active side's turn.
template ActiveSideOfGame
  with
    player : Party
    side : Side
    operator : Party
    opponent : Party
    gameId : GameId
    active : GameState
  where
    signatory player, operator
    key (operator, gameId, player) : SideKey
    maintainer key._1

    controller player can
      nonconsuming Move : ContractId ActiveMove
        with
          move : ChessMove
        do
          create ActiveMove with ..

      Forfeit : ContractId Surrender
        do
          create Surrender with ..

    controller operator can
      -- operator can only take this action after receiving a unique Move,
      Inactivate : ContractId PassiveSideOfGame
        with
          passive : GameState
        do
          create PassiveSideOfGame with ..

      DeclareWinnerActive : ContractId GameResult --
        with
          result : ContractId GameResult
        do
          return result

template Surrender
  with
    player : Party
    operator : Party
    gameId : GameId
    opponent : Party
  where
    signatory operator, player

    key (operator, gameId) : (Party, GameId)
    maintainer key._1

template DrawRequest
  with
    player : Party
    operator : Party
    gameId : GameId
    opponent : Party
    side : Side
    -- reveal : Bool -- add?
  where
    signatory operator, player

    key (operator, gameId, player) : (Party, GameId, Party)
    maintainer key._1

    controller opponent can
      AcceptDrawRequest : ContractId AcceptedDraw
        do create AcceptedDraw with ..

template AcceptedDraw
  with
    player : Party
    operator : Party
    gameId : GameId
    opponent : Party
    side : Side
  where
    signatory player, opponent
    key (operator, gameId) : (Party, GameId)
    maintainer key._1

template ActiveMove
  with
    player : Party
    operator : Party
    gameId : GameId
    opponent : Party
    move : ChessMove
  where
    signatory operator

    key (operator, gameId) : (Party, GameId)
    maintainer key._1

template OperatorRole
  with
    operator : Party
    gameId : GameId
  where
    signatory operator

    key (operator, gameId) : (Party, GameId)
    maintainer key._1

    controller operator can
      -- operator's reaction to the existence of an ActiveMove
      nonconsuming AdvancePlay : Either (ContractId GameResult) GameContractIds
        do
          -- Look up move information from ActiveMove and archive it
          (amId, activeMove) <- fetchByKey @ActiveMove (operator, gameId)

          let player = activeMove.player
              opponent = activeMove.opponent
              move = activeMove.move
          exercise amId Archive

          -- figure out global state
          (activeId, activeState) <- fetchByKey @ActiveSideOfGame (operator, gameId, player)
          (passiveId, passiveState) <- fetchByKey @PassiveSideOfGame (operator, gameId, opponent)
          let gameState = joinGameStates activeState.active passiveState.passive
              moveSide = activeState.side
          case tryMove gameState move of
            -- determine winner
            Winner player ->
              let winner = if player == moveSide then activeState.player else activeState.opponent in
              let game = (gameState with moves = move :: gameState.moves) in
              do
                (gameStartId, gameStart) <- fetchByKey @Game (operator, gameId)
                gameResultId <- exercise gameStartId End with game = Some game, drawOrWinner = Right winner, ..
                exercise activeId DeclareWinnerActive with result = gameResultId
                exercise passiveId DeclareWinnerPassive with result = gameResultId
                return $ Left gameResultId
            -- determine draw
            Draw drawType ->
              do
                (gameStartId, gameStart) <- fetchByKey @Game (operator, gameId)
                gameResultId <- exercise gameStartId End with game = None, drawOrWinner = Left drawType, ..
                exercise activeId DeclareWinnerActive with result = gameResultId
                exercise passiveId DeclareWinnerPassive with result = gameResultId
                return $ Left gameResultId
            -- determine hmm ?
            Error e -> abort e
            -- alternate states
            NewState newJoinedState ->
              let whiteState = splitGameStateOfSide White newJoinedState
                  blackState = splitGameStateOfSide Black newJoinedState
                  (active, passive) =
                    case moveSide of
                      White -> (blackState, whiteState)
                      Black -> (whiteState, blackState)
              in
              do
                passiveId' <- exercise activeId Inactivate with passive
                activeId' <- exercise passiveId Activate with active
                return $ Right (activeId', passiveId')

      -- operator's reaction to the existence of an Surrender
      nonconsuming AcknowledgeSurrender : ContractId GameResult
        do
          (sId, surrender) <- fetchByKey @Surrender (operator, gameId)
          (gameStartId, _gameStart) <- fetchByKey @Game (operator, gameId)
          archive sId
          exercise gameStartId End with game = None, drawOrWinner = Right surrender.opponent, ..

      nonconsuming AcknowledgeAcceptedDraw : ContractId GameResult
        do
          (adId, acceptedDraw) <- fetchByKey @AcceptedDraw (operator, gameId)
          (gameStartId, _gameStart) <- fetchByKey @Game (operator, gameId)
          archive adId
          exercise gameStartId End with game = None, drawOrWinner = Left (PlayerDraw acceptedDraw.side)
