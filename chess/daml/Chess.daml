-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Chess where

import DA.Assert

import Rules.Main
import Rules.Data
import Rules.Draw
import Types

-- As part of beginning operator flow
-- we'll refactor this later to create gameId's.

type GameContractIds = (ContractId ActiveSideOfGame, ContractId PassiveSideOfGame)

template GameProposal
  with
    gameId : GameId
    proposer : Party
  where
    let opponent = oppositeParty proposer gameId
        operator = gameId.operator
    signatory proposer
    controller opponent can
      InitGame : ContractId GameStart
        do
          create GameStart with ..

template GameStart
  with
    proposer : Party
    opponent : Party
    operator : Party
    gameId : GameId
  where
    signatory proposer, opponent
    controller operator can
      Start : GameContractIds
        do
          passiveId <- create PassiveSideOfGame with
                        player = opponent
                        passive = Rules.Data.initSplitState Black
                        ..
          activeId <- create ActiveSideOfGame with
                        player = proposer
                        active = Rules.Data.initSplitState White
                        ..
          return (activeId, passiveId)

template GameResult
  with
    gameId : GameId
    game : Optional GameState
    winner : Optional Party
  where
    signatory gameId.operator

type SideKey = (Party, GameId)

template PassiveSideOfGame
  with
    player : Party
    operator : Party
    gameId : GameId
    passive : SplitGameState
  where
    signatory player, operator
    key (operator, gameId) : SideKey
    maintainer key._1

    controller operator can
      Activate : ContractId ActiveSideOfGame
        with
          active : SplitGameState
        do
          create ActiveSideOfGame with ..
      End : ContractId GameResult
        with
          winner : Optional Party
          game : Optional GameState
        do
          create GameResult with ..

    controller player can
      Resign : ContractId GameResult
        do
          let opponent = oppositeParty player gameId
          create GameResult with winner = Some opponent, game = None, ..

template ActiveSideOfGame
  with
    player : Party
    operator : Party
    gameId : GameId
    active : SplitGameState
  where
    signatory player, operator
    key (operator, gameId) : SideKey
    maintainer key._1

    controller player can
      nonconsuming Move : ContractId ActiveMove
        with
          move : ChessMove
        do
          create ActiveMove with ..

    controller [operator, player] can
      MakePassive : ContractId PassiveSideOfGame
        with
          move : ChessMove
        do
          let passive = active with moves = move :: active.moves
          create PassiveSideOfGame with ..

template ActiveMove
  with
    player : Party
    operator : Party
    gameId : GameId
    active : SplitGameState
    move : ChessMove
  where
    signatory operator, player

    -- need a unique key to prevent double moves.
    key (operator, gameId, move) : (Party, GameId, ChessMove)
    maintainer key._1

    controller operator can
      AdvancePlay : Either (ContractId GameResult) GameContractIds
        do
          (passiveId, passiveState) <- fetchByKey @PassiveSideOfGame (operator, gameId)
          (activeId, activeState) <- fetchByKey @ActiveSideOfGame (operator, gameId)
          let joinedState = joinGameStates active.player active passiveState.passive
          case tryMove joinedState move of
            Winner player ->
              let winner =  if player == White then gameId.white else gameId.black in
              do
                win <- exercise passiveId End with
                            winner = Some winner
                            game = Some joinedState
                -- TODO: End the activeState too
                return $ Left win
            Error e -> abort e
            NewState newJoinedState ->
              let whiteState = splitGameStateOfPlayer White newJoinedState
                  blackState = splitGameStateOfPlayer Black newJoinedState
                  active = if move.by == White then blackState else whiteState
              in
              do
                passiveId <- exercise activeId MakePassive with move
                activeId <- exercise passiveId Activate with ..
                return $ Right (activeId, passiveId)