-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Chess where


import Rules.Main
import Rules.Data
import Types

type GameId = Text
type GameContractIds = (ContractId ActiveSideOfGame, ContractId PassiveSideOfGame)

template GameProposal
  with
    gameId : GameId
    proposer : Party
    desiredSide : Player
    opponent : Party
    operator : Party
  where
    signatory proposer
    -- Only one game from proposer with the same id
    key (proposer, gameId) : (Party, GameId)
    maintainer key._1

    controller opponent can
      Accept : ContractId GameAccept
        do create GameAccept with ..

template GameAccept
  with
    gameId : GameId
    proposer : Party
    desiredSide : Player
    opponent : Party
    operator : Party
  where
    signatory proposer, opponent

    controller operator can
      Start : ContractId Game
        do create Game with ..

template Game
  with
    gameId : GameId
    proposer : Party
    desiredSide : Player
    opponent : Party
    operator : Party
  where
    signatory proposer, opponent, operator
    key (operator, gameId) : (Party, GameId)
    maintainer key._1
    controller operator can
      nonconsuming Begin : GameContractIds
        do
          let (activePlayer, passivePlayer) =
                case desiredSide of
                  White -> (proposer, opponent)
                  Black -> (opponent, proposer)

          activeId <- create ActiveSideOfGame with
                          player = activePlayer
                          opponent = passivePlayer
                          active = Rules.Data.initSplitState White
                          side = White
                          ..
          passiveId <- create PassiveSideOfGame with
                          player = passivePlayer
                          opponent = activePlayer
                          passive = Rules.Data.initSplitState Black
                          side = Black
                          ..
          return (activeId, passiveId)

      End : ContractId GameResult
        with
          game : Optional GameState
          winner : Optional Party
        do
          create GameResult with ..

template GameResult
  with
    opponent : Party
    proposer : Party
    gameId : GameId
    operator : Party
    game : Optional GameState
    winner : Optional Party
  where
    signatory proposer, opponent, operator

type SideKey = (Party, GameId, Party)

template PassiveSideOfGame
  with
    player : Party
    side : Player
    operator : Party
    opponent : Party
    gameId : GameId
    passive : SplitGameState
  where
    signatory player, operator
    key (operator, gameId, player) : SideKey
    maintainer key._1

    controller operator can
      Activate : ContractId ActiveSideOfGame
        with
          active : SplitGameState
        do create ActiveSideOfGame with ..
      DeclareWinnerPassive : ContractId GameResult --
        with
          result : ContractId GameResult
        do return result

    controller player can
      Resign : ContractId Surrender
        do create Surrender with ..
      AskForADraw : ContractId DrawRequest
        do create DrawRequest with ..

-- It is the active side's turn.
template ActiveSideOfGame
  with
    player : Party
    side : Player
    operator : Party
    opponent : Party
    gameId : GameId
    active : SplitGameState
  where
    signatory player, operator
    key (operator, gameId, player) : SideKey
    maintainer key._1

    controller player can
      nonconsuming Move : ContractId ActiveMove
        with
          move : ChessMove
        do
          create ActiveMove with ..

      Forfeit : ContractId Surrender
        do
          create Surrender with ..

    controller operator can
      -- operator can only take this action after receiving a unique Move,
      Inactivate : ContractId PassiveSideOfGame
        with
          passive : SplitGameState
        do
          create PassiveSideOfGame with ..

      DeclareWinnerActive : ContractId GameResult --
        with
          result : ContractId GameResult
        do
          return result

template Surrender
  with
    player : Party
    operator : Party
    gameId : GameId
    opponent : Party
  where
    signatory operator, player

    key (operator, gameId) : (Party, GameId)
    maintainer key._1

template DrawRequest
  with
    player : Party
    operator : Party
    gameId : GameId
    opponent : Party
    -- reveal : Bool -- add?
  where
    signatory operator, player

    key (operator, gameId, player) : (Party, GameId, Party)
    maintainer key._1

    controller opponent can
      AcceptDrawRequest : ContractId AcceptedDraw
        do create AcceptedDraw with ..

template AcceptedDraw
  with
    player : Party
    operator : Party
    gameId : GameId
    opponent : Party
  where
    signatory player, opponent
    key (operator, gameId) : (Party, GameId)
    maintainer key._1

template ActiveMove
  with
    player : Party
    operator : Party
    gameId : GameId
    opponent : Party
    move : ChessMove
  where
    signatory operator

    key (operator, gameId) : (Party, GameId)
    maintainer key._1

template OperatorRole
  with
    operator : Party
    gameId : GameId
  where
    signatory operator

    key (operator, gameId) : (Party, GameId)
    maintainer key._1

    controller operator can
      -- operator's reaction to the existence of an ActiveMove
      nonconsuming AdvancePlay : Either (ContractId GameResult) GameContractIds
        do
          -- Look up move information from ActiveMove and archive it
          (amId, activeMove) <- fetchByKey @ActiveMove (operator, gameId)

          let player = activeMove.player
              opponent = activeMove.opponent
              move = activeMove.move
          exercise amId Archive

          -- figure out global state
          (activeId, activeState) <- fetchByKey @ActiveSideOfGame (operator, gameId, player)
          (passiveId, passiveState) <- fetchByKey @PassiveSideOfGame (operator, gameId, opponent)
          let gameState = joinGameStates activeState.side activeState.active passiveState.passive
              moveSide = activeState.side
          case tryMove gameState move of
            -- determine winner
            Winner player ->
              let winner = if player == moveSide then activeState.player else activeState.opponent in
              let game = (gameState with moves = (moveSide, move) :: gameState.moves) in
              do
                (gameStartId, gameStart) <- fetchByKey @Game (operator, gameId)
                gameResultId <- exercise gameStartId End with game = Some game, winner = Some winner, ..
                exercise activeId DeclareWinnerActive with result = gameResultId
                exercise passiveId DeclareWinnerPassive with result = gameResultId
                return $ Left gameResultId
            -- determine hmm ?
            Error e -> abort e
            -- alternate states
            NewState newJoinedState ->
              let whiteState = splitGameStateOfPlayer White newJoinedState
                  blackState = splitGameStateOfPlayer Black newJoinedState
                  (active, passive) =
                    case moveSide of
                      White -> (blackState, whiteState)
                      Black -> (whiteState, blackState)
              in
              do
                passiveId' <- exercise activeId Inactivate with passive
                activeId' <- exercise passiveId Activate with active
                return $ Right (activeId', passiveId')

      -- operator's reaction to the existence of an Surrender
      nonconsuming AcknowledgeSurrender : ContractId GameResult
        do
          (sId, surrender) <- fetchByKey @Surrender (operator, gameId)
          (gameStartId, _gameStart) <- fetchByKey @Game (operator, gameId)
          let winner = Some surrender.opponent
          archive sId
          exercise gameStartId End with game = None, winner = winner, ..

      nonconsuming AcknowledgeAcceptedDraw : ContractId GameResult
        do
          (adId, acceptedDraw) <- fetchByKey @AcceptedDraw (operator, gameId)
          (gameStartId, _gameStart) <- fetchByKey @Game (operator, gameId)
          archive adId
          exercise gameStartId End with game = None, winner = None, ..
