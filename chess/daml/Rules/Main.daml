-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Rules.Main where

import DA.Either
import DA.Foldable as F
import DA.Next.Map as M
import DA.Optional

import Types

import Rules.Castle
import Rules.Data
import Rules.Move
import Rules.Path


-- | Tries to apply a `ChessMove` to a `GameState`.
tryMove : GameState -> ChessMove -> MoveResult
tryMove state move =
  case tryMoveInner state move of
    Left e -> Error e
    Right ns -> case checkWin ns of
      None -> NewState ns
      Some p -> DrawOrWinner (Right p)

tryMoveInner : GameState -> ChessMove -> E GameState
tryMoveInner state move = do
  md <- toMoveData state move

  newMap <- if isCastle md
    then castle md
    else simpleMove md

  newEverCheck <- checkCheck md newMap

  return state with
    side = if state.side == White then Black else White
    pieces = M.fromList $ fmap (\(ic, p) -> (toCoord ic, p)) $ M.toList newMap
    everCheck = newEverCheck
    moves = move :: state.moves


-- | Checks whether either player has won in a given game state
checkWin : GameState -> Optional Side
checkWin s =
    case hasKings of
      (True, True) -> None
      (False, _) -> Some Black
      (_, False) -> Some White
  where
    kingFn t p =
      (
        fst t || (owner p == White && p.tp == King),
        snd t || (owner p == Black && p.tp == King)
      )
    hasKings = F.foldl
      kingFn
      (False, False)
      s.pieces

-- | Checks whether the opponent player is checked and gives updated values
checkCheck : MoveData -> StateMap -> E EverCheck
checkCheck md stateMap =
  case md.move.check of
    None -> return md.state.everCheck
    Some (p, k) -> do
      let from = toIntCoord p
          to = toIntCoord k
      piece <- optionalToEither "Check from position not occupied" $ M.lookup from stateMap
      king <- optionalToEither "Check from position not occupied" $ M.lookup to stateMap
      assertMsg "Player doesn't own piece" (md.state.side == piece.owner)
      assertMsg "King invalid" (md.state.side /= king.owner && king.tp == King)
      movePath <- path piece.tp md.state.side True from to
      F.forA_ movePath (\c -> assertMsg "Check ath blocked" (isNone $ M.lookup c stateMap))
      if md.state.side == White
        then return $ md.state.everCheck with black = True
        else return $ md.state.everCheck with white = True
