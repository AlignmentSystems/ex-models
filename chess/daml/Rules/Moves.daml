-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Rules.Moves where

import DA.Next.Map qualified as M
import DA.Optional

import Types
import Rules.Data


onBoard1 : Int -> Bool
onBoard1 c = 0 <= c && c <= 7

onBoard : IntCoord -> Bool
onBoard (c, r) = onBoard1 c && onBoard1 r

knightOffsets = [ (1,2), (2,1), (2,-1), (1,-2), (-1,-2), (-2,-1), (-2,1), (-1,2) ]

knightPositions : IntCoord -> [IntCoord]
knightPositions (col, row) = mapOptional toOffsetOpt knightOffsets
    where toOffsetOpt (c, r) =
            let np = (col + c, row + r) in
            if onBoard np then Some np else None

data Direction = Up
               | RightUp
               | Right_
               | RightDown
               | Down_
               | LeftDown
               | Left_
               | LeftUp
    deriving (Eq, Enum)

moveD : IntCoord -> Direction -> IntCoord
moveD (c, r)  Up        = (c,     r + 1)
moveD (c, r)  RightUp   = (c + 1, r + 1)
moveD (c, r)  Right_    = (c + 1, r    )
moveD (c, r)  RightDown = (c + 1, r - 1)
moveD (c, r)  Down_     = (c,     r - 1)
moveD (c, r)  LeftDown  = (c - 1, r - 1)
moveD (c, r)  Left_     = (c - 1, r)
moveD (c, r)  LeftUp    = (c - 1, r + 1)

-- It would be easier to define many of these smaller functions within the
-- possibleMoves context so that they can refer to the piece.owner and gamestate
occupied : GameState -> IntCoord -> Bool
occupied gs ic = M.member (toCoord ic) gs.pieces

atPos : GameState -> IntCoord -> Optional Piece
atPos gs ic = M.lookup (toCoord ic) gs.pieces

oppositeAt : Side -> GameState -> IntCoord -> Optional Piece
oppositeAt side gs ic = atPos gs ic >>= \p -> if p.owner /= side then Some p else None

type MoveOrCapture = Either IntCoord Piece

notOccupied : GameState -> [IntCoord] -> [MoveOrCapture]
notOccupied gs = fmap Left . filter (not . occupied gs) . filter onBoard

onlyCapture : Side -> GameState -> IntCoord -> Optional MoveOrCapture
onlyCapture side gs ic = oppositeAt side gs ic >>= \p -> Some $ Right p

onlyCaptures : Side -> GameState -> [IntCoord] -> [MoveOrCapture]
onlyCaptures side gs = mapOptional (onlyCapture side gs) . filter onBoard

moveOrCapture : Side -> GameState -> IntCoord -> Optional MoveOrCapture
moveOrCapture side gs ic =
    case atPos gs ic of
        None -> Some $ Left ic
        Some p -> if p.owner == side
                  then None
                  else Some $ Right p

movesOrCaptures : Side -> GameState -> [IntCoord] -> [MoveOrCapture]
movesOrCaptures side gs = mapOptional (moveOrCapture side gs) . filter onBoard

follow : Side -> GameState -> IntCoord -> Direction -> [MoveOrCapture]
follow side gs ic d =
    let nic = moveD ic d in
    if not $ onBoard nic
    then []
    else case atPos gs nic of
            None -> Left nic :: follow side gs nic d
            Some p -> if p.owner == side
                      then []
                      else [Right p]

followDs : Side -> GameState -> IntCoord -> [Direction] -> [MoveOrCapture]
followDs side gs ic ds = concatMap (follow side gs ic) ds

possibleMoves : Piece -> GameState -> [MoveOrCapture]
possibleMoves piece gs =
    let ps = piece.owner

        ic = toIntCoord piece.coord
    in
    case piece.tp of
        Pawn ->
            let (c, r) = ic
                checkEnPassant : () -> [MoveOrCapture]
                checkEnPassant () =
                    case gs.moves of
                        m :: _ ->
                            let oppositeSide = m.by /= piece.owner
                                movedTwo = rowD (toIntCoord m.from) (toIntCoord m.to) == 2
                                colCoord = fst $ toIntCoord m.from
                                pastMyAttacks = colCoord == (c-1) || colCoord == (c+1)
                                lastMovedPiece = M.lookup m.to gs.pieces
                            in
                            case lastMovedPiece of
                                Some p -> if p.tp == Pawn && oppositeSide && movedTwo && pastMyAttacks
                                          then [ Right p ]
                                          else []
                                None -> []
                        _ -> []
            in
            case (piece.owner, r) of
                (White, 0)  -> error "Pawns can't move backwards"
                (White, 1)  -> notOccupied gs [(c, r+1), (c, r+2)] ++
                               onlyCaptures ps gs[(c-1,r+1), (c+1,r+1)]
                (White, 5)  -> notOccupied gs [(c, r + 1)] ++
                               onlyCaptures ps gs[(c-1,r+1), (c+1,r+1)] ++
                               checkEnPassant ()
                (White, 7)  -> error "Must promote before end."
                (White, _)  -> notOccupied gs [(c, r + 1)] ++
                               onlyCaptures ps gs[(c-1,r+1), (c+1,r+1)]

                (Black, 7)  -> error "Pawns can't move backwards"
                (Black, 6)  -> notOccupied gs [(c, r - 1), (c, r - 2)] ++
                               onlyCaptures ps gs[(c-1,r-1), (c+1,r-1)]
                (Black, 4)  -> notOccupied gs [(c, r - 1)] ++
                               onlyCaptures ps gs[(c-1,r-1), (c+1,r-1)] ++
                               checkEnPassant ()
                (Black, 0)  -> error "Must promote before end."
                (Black, _)  -> notOccupied gs [(c, r - 1)] ++
                               onlyCaptures ps gs[(c-1,r-1), (c+1,r-1)]

        Knight -> movesOrCaptures ps gs $ knightPositions ic
        Bishop -> followDs ps gs ic [RightUp, RightDown, LeftDown, LeftUp]
        Rook -> followDs ps gs ic [Up, Right_, Down_, Left_]
        Queen -> followDs ps gs ic [Up .. ]
        -- TODO: add castling
        King -> movesOrCaptures ps gs $ filter onBoard $ fmap (moveD ic) [Up .. ]

-- The type of the f in foldMoves
-- the piece is repeated for all possible MoveOrCapture's
type FoldMoveFunction a = a -> Piece -> MoveOrCapture -> a

--foldMoves : FoldMoveFunction a -> a -> Side -> GameState -> a
--foldMoves f init side gs = foldP
--    where fp piece a =
    -- for each piece