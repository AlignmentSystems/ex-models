-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Types where

import DA.Next.Map qualified as M
import DA.Optional

--data GameId = GameId with
--  ref : Text
--  white : Party
-- black : Party
--  operator : Party
--    deriving (Eq, Show)

--oppositeParty : Party -> GameId -> Party
--oppositeParty player gameId =
--  if player == gameId.white
--  then gameId.black
--  else gameId.white

data PieceType =
  Pawn | Rook | Knight | Bishop | Queen | King
    deriving (Eq, Show, Ord)

data Player =
  Black | White
    deriving (Eq, Show, Ord)

oppositePlayer : Player -> Player
oppositePlayer White = Black
oppositePlayer Black = White

data Coord = A1 | A2 | A3 | A4 | A5 | A6 | A7 | A8
           | B1 | B2 | B3 | B4 | B5 | B6 | B7 | B8
           | C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8
           | D1 | D2 | D3 | D4 | D5 | D6 | D7 | D8
           | E1 | E2 | E3 | E4 | E5 | E6 | E7 | E8
           | F1 | F2 | F3 | F4 | F5 | F6 | F7 | F8
           | G1 | G2 | G3 | G4 | G5 | G6 | G7 | G8
           | H1 | H2 | H3 | H4 | H5 | H6 | H7 | H8
    deriving (Eq, Show, Ord, Enum)

instance M.MapKey Coord where
  keyToText c = M.keyToText $ fromEnum c
  keyFromText t = toEnum $ M.keyFromText t

data Piece = Piece with
  coord : Coord
  tp : PieceType
  owner : Player
  moved : Bool
    deriving (Eq, Show, Ord)

data EverCheck = EverCheck with
  white : Bool
  black : Bool
    deriving (Eq, Show)

data ChessMove = ChessMove with
  from : Coord
  to : Coord
  promote : Optional PieceType
  check : Optional (Coord, Coord)
    deriving (Eq, Show)

data GameState = GameState with
  player : Player                 -- who's turn is it
  pieces : [Piece]                -- pieces left on the board.
  everCheck : EverCheck           -- has either side been checked
  moves : [(Player, ChessMove)]   -- reverse ordered list of moves.
    deriving (Eq, Show)

-- In Fog-Of-War variant each player has this.
data SplitGameState = SplitGameState with
  player : Player
  pieces : [Piece]
  everCheck : Bool
  moves : [ChessMove]
    deriving (Eq, Show)

-- this is a bit naive at-the-moment, in real fog-of-war white would be able to see black pieces that it is threatening.
splitGameStateOfPlayer : Player -> GameState -> SplitGameState
splitGameStateOfPlayer player gs =
  SplitGameState with
    player = gs.player
    pieces = filter (\p -> p.owner == player) gs.pieces
    everCheck = case player of
                  White -> gs.everCheck.white
                  Black -> gs.everCheck.black
    moves = mapOptional (\(p,m) -> if p == player then Some m else None) gs.moves

mergeMoves acc (w::ws) (b::bs) = mergeMoves (b::(w::acc)) ws bs
mergeMoves acc [w]     []      = reverse (w :: acc) -- white may have an extra move
mergeMoves acc []      []      = reverse acc
mergeMoves _   _       _       = error "More black moves than white ones!"

joinGameStates : Player -> SplitGameState -> SplitGameState -> GameState
joinGameStates turn s1 s2 =
  let (ws, bs) = case s1.player of
              White -> (s1, s2)
              Black -> (s2, s1)
  in
  GameState with
    player = turn
    pieces = s1.pieces ++ s2.pieces
    everCheck = EverCheck with white = ws.everCheck; black = bs.everCheck
    moves = mergeMoves [] (fmap (\m -> (White,m)) ws.moves) (fmap (\m ->(Black,m)) bs.moves)


data MoveResult
  = Winner Player
  | NewState GameState
  | Error Text
